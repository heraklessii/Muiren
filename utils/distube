const Discord = require("discord.js")
const { EmbedBuilder, ButtonBuilder, ActionRowBuilder, ButtonStyle } = require('discord.js');
const { JsonDatabase } = require("wio.db");
const db = new JsonDatabase({
  databasePath: "./Depo/muzik.json"
});

module.exports = async (client) => {

  client.distube.on('playSong', async (queue) => {

    client.UpdateQueueMsg(queue)

    const data = db.get(`müzikSunucu-${queue.id}.setupAyarlar`);

    if (!data || data.sistemDurumu === false || data.sistemDurumu === null) {

      const embeded = new EmbedBuilder()
        .setAuthor({ name: `Şarkı oynatılıyor...`, iconURL: 'https://cdn.discordapp.com/emojis/741605543046807626.gif' })
        .setImage(queue.songs[0].thumbnail)
        .setColor(client.color)
        .setDescription(`**[${queue.songs[0].name}](${queue.songs[0].url})**`)
        .addFields({ name: `Oynatan Kişi:`, value: `${queue.songs[0].user}`, inline: true })
        .addFields({ name: `Mevcut Ses:`, value: `**%${queue.volume}**`, inline: true })
        .addFields({ name: `Filtreler:`, value: `**${queue.filters.names.join(", ") || "Kapalı"}**`, inline: true })
        .addFields({ name: `Oto Oynatma:`, value: `**${queue.autoplay ? "Açık" : "Kapalı"}**`, inline: true })
        .addFields({ name: `Toplam Süre:`, value: `${queue.songs[0].formattedDuration}`, inline: true })
        .addFields({ name: `Mevcut Süre: \`[0:00 / ${queue.songs[0].formattedDuration}]\``, value: `\`\`\`🔴 | 🎶 ───────────────────────────────────────────\`\`\``, inline: false })
        .setTimestamp()

      const row = new ActionRowBuilder()
        .addComponents(
          new ButtonBuilder()
            .setCustomId("pause")
            .setEmoji("⏯")
            .setStyle(ButtonStyle.Success)
        )
        .addComponents(
          new ButtonBuilder()
            .setCustomId("previous")
            .setEmoji("⬅")
            .setStyle(ButtonStyle.Primary)
        )
        .addComponents(
          new ButtonBuilder()
            .setCustomId("stop")
            .setEmoji("✖")
            .setStyle(ButtonStyle.Danger)
        )
        .addComponents(
          new ButtonBuilder()
            .setCustomId("skip")
            .setEmoji("➡")
            .setStyle(ButtonStyle.Primary)
        )
        .addComponents(
          new ButtonBuilder()
            .setCustomId("loop")
            .setEmoji("🔄")
            .setStyle(ButtonStyle.Success)
        )

      const nowplay = await queue.textChannel.send({ embeds: [embeded], components: [row] })

      const filter = (interaction) => {

        if (interaction.guild.members.me.voice.channel && interaction.guild.members.me.voice.channelId === interaction.member.voice.channelId) return true;

        else {

          interaction.reply({ content: ":x: | Butonları kullanabilmek için benimle aynı ses kanalında olmalısın.", ephemeral: true })

        }

      };

      const collector = nowplay.createMessageComponentCollector({ filter, time: queue.songs[0].duration * 1000 });

      collector.on('collect', async (interaction) => {

        const id = interaction.customId;

        const queue = client.distube.getQueue(interaction.guild.id);

        if (interaction.user.id != queue.songs[0].user) return interaction.reply({
          content: `:x: | ${interaction.user}, oynatılan şarkıyı siz eklemediğiniz için butonları kullanamazsınız.`,
          ephemeral: true,
        })

        if (id === "pause") {

          if (!queue) {

            collector.stop();

          }

          if (queue.paused) {

            await client.distube.resume(interaction.guild.id);

            const embed = new EmbedBuilder()
              .setColor(client.color)
              .setDescription(`⏯ | Şarkı devam ettiriliyor.`);

            interaction.reply({ embeds: [embed], ephemeral: true })

          } else {

            await client.distube.pause(interaction.guild.id);

            const embed = new EmbedBuilder()
              .setColor(client.color)
              .setDescription(`⏯ | Şarkı durduruluyor.`);

            interaction.reply({ embeds: [embed], ephemeral: true })

          }

        } else if (id === "skip") {

          if (!queue) {

            collector.stop();

          }

          if (queue.songs.length === 1 && queue.autoplay === false) {

            const embed = new EmbedBuilder()
              .setColor(client.color)
              .setDescription(":x: | Sırada atlanacak hiç şarkı yok.")

            interaction.reply({ embeds: [embed], ephemeral: true })

          } else {

            await client.distube.skip(interaction)

            const embed = new EmbedBuilder()
              .setColor(client.color)
              .setDescription("⏭ | Şarkı başarıyla atlandı.")

            nowplay.delete();

            collector.stop();

            interaction.reply({ embeds: [embed], ephemeral: true })

          }

        } else if (id === "stop") {

          if (!queue) {

            collector.stop();

          }

          await client.distube.stop(interaction.guild.id);

          const embed = new EmbedBuilder()
            .setDescription(`🚫 | Şarkı oynatmayı bitirdim.`)
            .setColor(client.color);

          nowplay.delete();
          collector.stop();

          interaction.reply({ embeds: [embed], ephemeral: true })

        } else if (id === "loop") {

          if (!queue) {

            collector.stop();

          }

          if (queue.repeatMode === 0) {

            client.distube.setRepeatMode(interaction.guild.id, 1);

            const embed = new EmbedBuilder()
              .setColor(client.color)
              .setDescription(`🔁 | Şarkı tekrar modu aktif edildi.`)

            interaction.reply({ embeds: [embed], ephemeral: true })

          } else {

            client.distube.setRepeatMode(interaction.guild.id, 0);

            const embed = new EmbedBuilder()
              .setColor(client.color)
              .setDescription(`🔁 | Şarkı tekrar modu kapatıldı.`)

            interaction.reply({ embeds: [embed], ephemeral: true })

          }

        } else if (id === "previous") {

          if (!queue) {

            collector.stop();

          }

          if (queue.previousSongs.length == 0) {

            const embed = new EmbedBuilder()
              .setColor(client.color)
              .setDescription(":x: | Oynatılacak eski bir şarkı bulunamadı!")

            interaction.reply({ embeds: [embed], ephemeral: true })

          } else {

            await client.distube.previous(interaction)

            const embed = new EmbedBuilder()
              .setColor(client.color)
              .setDescription("⏮ | Eski şarkı oynatılıyor.")

            nowplay.delete();

            collector.stop();

            interaction.reply({ embeds: [embed], ephemeral: true })

          }
        }

      });

      collector.on('end', async (collected, reason) => {

        if (reason === "time") {

          nowplay.delete();

        }

      });

    }

    else if (data && data.sistemDurumu === true) return;

  })

  client.distube.on('addSong', (queue, song) => {

    const data = db.get(`müzikSunucu-${queue.id}.setupAyarlar`);

    if (!data || data.sistemDurumu === false || data.sistemDurumu === null) {

      const embed = new EmbedBuilder()

        .setDescription(`${client.emotes.success} | **[${song.name}](${song.url})** \`${song.formattedDuration}\` • ${song.user}`)
        .setColor(client.green)

      return queue.textChannel.send({ embeds: [embed] }).then((sent) => {
        setTimeout(() => {
          sent.delete();
        }, 5000);
      });

    }

    else if (data.sistemDurumu === true) return;

  })

  client.distube.on('addList', (queue, playlist) => {

    const data = db.get(`müzikSunucu-${queue.id}.setupAyarlar`);

    if (!data || data.sistemDurumu === false || data.sistemDurumu === null) {

      const embed = new EmbedBuilder()
        .setDescription(`${client.emotes.success} | **[${playlist.name}](${playlist.url})** \`${queue.formattedDuration}\` (${playlist.songs.length} şarkı) • ${playlist.user}`)
        .setColor(client.green)

      return queue.textChannel.send({ embeds: [embed] }).then((sent) => {
        setTimeout(() => {
          sent.delete();
        }, 5000);
      });

    }

    else if (data.sistemDurumu === true) return;

  })

  client.distube.on('initQueue', (queue) => {

    return queue.volume = 100;

  })

  client.distube.on('empty', (queue) => {

    client.UpdateMusic(queue);

    const embed = new EmbedBuilder()
      .setColor(client.red)
      .setDescription(`:musical_note: | Kanalda tek başıma kaldım! Ayrılıyorum.`)

    return queue.textChannel.send({ embeds: [embed] }).then((sent) => {
      setTimeout(() => {
        sent.delete();
      }, 5000);
    });

  })

  client.distube.on('error', (e) => {

    const channel = process.env.LOGS
    const Channel = client.channels.cache.get(channel)

    const embed = new EmbedBuilder()
      .setDescription(`❌ | Bir hata meydana geldi: ${e.toString().slice(0, 1900)}`)
      .setColor(client.red)

    return Channel.send({ embeds: [embed] })

  })

  client.distube.on('finish', (queue) => {

    const data = db.get(`müzikSunucu-${queue.id}.setupAyarlar`);

    if (!data || data.sistemDurumu === false || data.sistemDurumu === null) {

      client.UpdateMusic(queue)
      client.distube.voices.leave(queue.textChannel.guild);

      const embed = new Discord.EmbedBuilder()
        .setDescription(`:musical_note: | Listedeki bütün şarkıları oynatmayı bitirdim.`)
        .setColor(client.green)

      return queue.textChannel.send({ embeds: [embed] }).then((sent) => {
        setTimeout(() => {
          sent.delete();
        }, 5000);
      });

    }

    else if (data && data.sistemDurumu === true) {

      client.UpdateMusic(queue)

      const embed = new Discord.EmbedBuilder()
        .setDescription(`:musical_note: | Listedeki bütün şarkıları oynatmayı bitirdim.`)
        .setColor(client.green)

      return queue.textChannel.send({ embeds: [embed] }).then((sent) => {
        setTimeout(() => {
          sent.delete();
        }, 5000);
      });


    }

  })

  client.distube.on('searchNoResult', (message, query) => {

    const embed = new EmbedBuilder()
      .setDescription(`❌ | \`${query}\` ile eşleşen sonuç bulamadım...`)
      .setColor(client.red)

    return message.channel.send({ embeds: [embed] }).then((sent) => {
      setTimeout(() => {
        sent.delete();
      }, 5000);
    });

  })

  client.distube.on('noRelated', (queue) => {

    const embed = new EmbedBuilder()
      .setDescription(`❌ | Oynatılacak şarkı bulamadım!`)
      .setColor(client.red)

    return queue.textChannel.send({ embeds: [embed] }).then((sent) => {
      setTimeout(() => {
        sent.delete();
      }, 5000);
    });

  })

  client.UpdateQueueMsg = async function (queue) {

    const MusicButtons2 = new Discord.ActionRowBuilder()
      .addComponents([
        new Discord.ButtonBuilder()
          .setStyle(ButtonStyle.Secondary)
          .setCustomId("spause")
          .setEmoji("⏯"),
        new Discord.ButtonBuilder()
          .setStyle(ButtonStyle.Secondary)
          .setCustomId("sprevious")
          .setEmoji("⬅"),
        new Discord.ButtonBuilder()
          .setStyle(ButtonStyle.Secondary)
          .setCustomId("sstop")
          .setEmoji("⏹"),
        new Discord.ButtonBuilder()
          .setStyle(ButtonStyle.Secondary)
          .setCustomId("sskip")
          .setEmoji("➡"),
        new Discord.ButtonBuilder()
          .setStyle(ButtonStyle.Secondary)
          .setCustomId("sloop")
          .setEmoji("🔄"),
      ]);

    const CheckDB = db.fetch(`müzikSunucu-${queue.id}`);
    if (!CheckDB) return;

    const data = db.get(`müzikSunucu-${queue.id}.setupAyarlar`);
    if (!data || data.sistemDurumu === false || data.sistemDurumu === null) return;

    const channel = client.channels.cache.get(data.kanal);
    if (!channel) return;

    const playMsg = await channel.messages.fetch(data.mesaj, { cache: false, force: true });
    if (!playMsg) return;

    const songStrings = [];
    const queuedSongs = queue.songs.map((song, i) => `*\`${i + 1} • ${song.name} • [${song.formattedDuration}]\`* • \`${song.user.tag}\``);

    songStrings.push(...queuedSongs);
    const Str = songStrings.slice(0, 10).join('\n');

    const cSong = queue.songs[0];
    const played = queue.playing ? `Oynatılıyor...` : `Durduruluyor...`;

    const embed = new EmbedBuilder()
      .setAuthor({ name: `${played}`, iconURL: "https://cdn.discordapp.com/emojis/741605543046807626.gif" })
      .setDescription(`[${cSong.name}](${cSong.url}) \`[${cSong.formattedDuration}]\` • ${cSong.user}`)
      .setColor(client.color)
      .setImage(`https://img.youtube.com/vi/${cSong.id}/sddefault.jpg`)
      .setFooter({ text: `${queue.songs.length} • Müzik Kuyrukta | Ses • %${queue.volume} | ${queue.formattedDuration} • Toplam Süre` })

    return playMsg.edit({
      content: `**__Şarkı Listesi:__**\n${Str == '' ? `Oynatılan şarkılar burada yer alacak.` : '\n' + Str}`,
      embeds: [embed],
      components: [MusicButtons2]
    }).catch((e) => { });
  };

  client.UpdateMusic = async function (queue) {

    const MusicButtons = new Discord.ActionRowBuilder()
      .addComponents([
        new Discord.ButtonBuilder()
          .setStyle(ButtonStyle.Secondary)
          .setCustomId("spause")
          .setEmoji("⏯")
          .setDisabled(true),
        new Discord.ButtonBuilder()
          .setStyle(ButtonStyle.Secondary)
          .setCustomId("sprevious")
          .setEmoji("⬅")
          .setDisabled(true),
        new Discord.ButtonBuilder()
          .setStyle(ButtonStyle.Secondary)
          .setCustomId("sstop")
          .setEmoji("⏹")
          .setDisabled(true),
        new Discord.ButtonBuilder()
          .setStyle(ButtonStyle.Secondary)
          .setCustomId("sskip")
          .setEmoji("➡")
          .setDisabled(true),
        new Discord.ButtonBuilder()
          .setStyle(ButtonStyle.Secondary)
          .setCustomId("sloop")
          .setEmoji("🔄")
          .setDisabled(true),
      ]);

    const CheckDB = db.fetch(`müzikSunucu-${queue.id}`);
    if (!CheckDB) return;

    const data = await db.get(`müzikSunucu-${queue.id}.setupAyarlar`);
    if (!data || data.sistemDurumu === false || data.sistemDurumu === null) return;

    const channel = client.channels.cache.get(data.kanal);
    if (!channel) return;

    const playMsg = await channel.messages.fetch(data.mesaj, { cache: false, force: true });
    if (!playMsg) return;

    const queueMsg = `**__Şarkı Listesi:__**\nOynatılan şarkılar burada yer alacak.`;
    const playEmbed = new EmbedBuilder()
      .setColor(client.color)
      .setAuthor({ name: `Henüz bu sunucuda şarkı oynatılmıyor.` })
      .setImage(`https://images3.alphacoders.com/110/1105694.jpg`)
      .setDescription(`>>> [Davet](https://discord.com/api/oauth2/authorize?client_id=${client.user.id}&permissions=2184310032&scope=bot%20applications.commands) | [Destek](https://discord.gg/muiren) | [İnternet Sitesi](https://muirenanime.net) | [Panel](http://panel.muirenanime.net)`)
      .setFooter({ text: `Ashii Müzik Sistemi` });

    return playMsg.edit({
      content: `${queueMsg}`,
      embeds: [playEmbed],
      components: [MusicButtons]
    }).catch((e) => { });

  };

}

